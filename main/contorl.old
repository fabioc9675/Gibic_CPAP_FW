#include <stdio.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "driver/uart.h"
#include "esp_log.h"


/*#include <stdio.h>
#include <math.h>

// Constantes y parámetros
#define PRESION_MINIMA 4.0    // Presión mínima de tratamiento (cmH2O)
#define PRESION_MAXIMA 20.0   // Presión máxima de tratamiento (cmH2O)
#define TIEMPO_MUESTREO 0.1   // Intervalo de muestreo en segundos
#define HORIZONTE_PREDICCION 10 // Horizonte de predicción (número de pasos)
#define COSTO_PRESION 1.0     // Peso para el error de presión
#define COSTO_CONTROL 0.1     // Peso para el esfuerzo de control

// Variables globales
float flujo_aire, presion_actual, presion_objetivo, pwm_output;
float modelo_presion[HORIZONTE_PREDICCION]; // Modelo de predicción de presión
float pwm_optimo[HORIZONTE_PREDICCION];     // Secuencia óptima de PWM

// Prototipos de funciones
float simular_modelo_presion(float presion_actual, float pwm);
void optimizar_secuencia_pwm(float modelo_presion[], float presion_objetivo, float pwm_optimo[]);
void ajustar_pwm(float pwm);

int main() {
    // Inicialización
    presion_objetivo = PRESION_MINIMA;  // Establecer presión inicial
    float error_anterior = 0;

    // Bucle principal
    while (1) {
        // Leer sensores (simulado)
        flujo_aire = leer_sensor_flujo();          // Función simulada
        presion_actual = leer_sensor_presion();    // Función simulada

        // Actualizar modelo de predicción
        for (int i = 0; i < HORIZONTE_PREDICCION; i++) {
            modelo_presion[i] = simular_modelo_presion(presion_actual, pwm_optimo[i]);
        }

        // Optimización de la secuencia de PWM
        optimizar_secuencia_pwm(modelo_presion, presion_objetivo, pwm_optimo);

        // Aplicar el primer valor de la secuencia óptima
        pwm_output = pwm_optimo[0];
        ajustar_pwm(pwm_output);

        // Esperar hasta el siguiente ciclo de muestreo (simulado)
        esperar(TIEMPO_MUESTREO);  // Función simulada
    }

    return 0;
}

// Función para simular el modelo de presión
float simular_modelo_presion(float presion_actual, float pwm) {
    // Simular la presión futura basada en el modelo del sistema
    // (Este es un ejemplo simplificado; el modelo real puede ser más complejo)
    float presion_futura = presion_actual + 0.1 * pwm;  // Ejemplo de modelo lineal
    return presion_futura;
}

// Función para optimizar la secuencia de PWM
void optimizar_secuencia_pwm(float modelo_presion[], float presion_objetivo, float pwm_optimo[]) {
    float costo_minimo = INFINITY;
    float secuencia_pwm[HORIZONTE_PREDICCION];

    // Búsqueda de la secuencia óptima (ejemplo simplificado)
    for (int i = 0; i < HORIZONTE_PREDICCION; i++) {
        float costo_total = 0;

        // Calcular costo total (error de presión + esfuerzo de control)
        for (int j = 0; j < HORIZONTE_PREDICCION; j++) {
            costo_total += COSTO_PRESION * pow(modelo_presion[j] - presion_objetivo, 2);
            costo_total += COSTO_CONTROL * pow(pwm_optimo[j], 2);
        }

        // Actualizar secuencia óptima si se encuentra un costo menor
        if (costo_total < costo_minimo) {
            costo_minimo = costo_total;
            for (int k = 0; k < HORIZONTE_PREDICCION; k++) {
                secuencia_pwm[k] = pwm_optimo[k];
            }
        }
    }

    // Copiar la secuencia óptima a pwm_optimo
    for (int i = 0; i < HORIZONTE_PREDICCION; i++) {
        pwm_optimo[i] = secuencia_pwm[i];
    }
}

// Función para ajustar el PWM (simulada)
void ajustar_pwm(float pwm) {
    printf("Ajustando PWM a: %.2f\n", pwm);
}

// Función para leer el sensor de flujo (simulada)
float leer_sensor_flujo() {
    // Simular lectura del sensor de flujo
    return 10.0;  // Valor simulado
}

// Función para leer el sensor de presión (simulada)
float leer_sensor_presion() {
    // Simular lectura del sensor de presión
    return 8.0;  // Valor simulado
}

// Función para esperar (simulada)
void esperar(float tiempo) {
    // Simular espera (en un sistema real, usaría un temporizador)
    printf("Esperando %.2f segundos...\n", tiempo);
}


/*
#include <stdio.h>
#include <qpOASES.hpp>

// Constantes y parámetros
#define HORIZONTE_PREDICCION 10 // Horizonte de predicción
#define PRESION_MINIMA 4.0      // Presión mínima (cmH2O)
#define PRESION_MAXIMA 20.0     // Presión máxima (cmH2O)
#define PWM_MIN 0.0             // PWM mínimo (0%)
#define PWM_MAX 100.0           // PWM máximo (100%)
#define Q 1.0                   // Peso para el error de presión
#define R 0.1                   // Peso para el esfuerzo de control

// Variables globales
float presion_actual, presion_objetivo;
float pwm_optimo[HORIZONTE_PREDICCION];

// Función para simular el modelo de presión
float simular_modelo_presion(float presion_actual, float pwm) {
    return presion_actual + 0.1 * pwm;  // Modelo lineal simplificado
}

// Función para optimizar la secuencia de PWM usando qpOASES
void optimizar_secuencia_pwm(float presion_actual, float presion_objetivo, float pwm_optimo[]) {
    // Definir el problema de optimización
    USING_NAMESPACE_QPOASES

    // Número de variables y restricciones
    int nV = HORIZONTE_PREDICCION;  // Número de variables (PWM en cada paso)
    int nC = 2 * HORIZONTE_PREDICCION; // Número de restricciones (límites de presión y PWM)

    // Matriz Hessiana (H) y vector gradiente (g)
    real_t H[nV * nV];
    real_t g[nV];

    // Matrices de restricciones (A) y límites (lb, ub, lbA, ubA)
    real_t A[nC * nV];
    real_t lb[nV], ub[nV];
    real_t lbA[nC], ubA[nC];

    // Inicializar matrices y vectores
    for (int i = 0; i < nV; i++) {
        for (int j = 0; j < nV; j++) {
            H[i * nV + j] = (i == j) ? Q + R : 0.0;  // Diagonal principal
        }
        g[i] = -Q * presion_objetivo;  // Vector gradiente
        lb[i] = PWM_MIN;               // Límite inferior del PWM
        ub[i] = PWM_MAX;               // Límite superior del PWM
    }

    // Definir restricciones de presión
    for (int i = 0; i < HORIZONTE_PREDICCION; i++) {
        for (int j = 0; j < nV; j++) {
            A[i * nV + j] = (i == j) ? 0.1 : 0.0;  // Coeficientes del modelo de presión
        }
        lbA[i] = PRESION_MINIMA - presion_actual;  // Límite inferior de presión
        ubA[i] = PRESION_MAXIMA - presion_actual;  // Límite superior de presión
    }

    // Crear y resolver el problema QP
    QProblem qp(nV, nC);
    int_t nWSR = 100;  // Número máximo de iteraciones
    qp.init(H, g, A, lb, ub, lbA, ubA, nWSR);

    // Obtener la solución óptima
    real_t xOpt[nV];
    qp.getPrimalSolution(xOpt);

    // Copiar la solución a pwm_optimo
    for (int i = 0; i < nV; i++) {
        pwm_optimo[i] = xOpt[i];
    }
}

// Función principal
int main() {
    // Inicialización
    presion_objetivo = 10.0;  // Presión objetivo (cmH2O)
    presion_actual = 8.0;     // Presión actual (cmH2O)

    // Optimizar la secuencia de PWM
    optimizar_secuencia_pwm(presion_actual, presion_objetivo, pwm_optimo);

    // Mostrar la secuencia óptima de PWM
    printf("Secuencia óptima de PWM:\n");
    for (int i = 0; i < HORIZONTE_PREDICCION; i++) {
        printf("PWM[%d] = %.2f\n", i, pwm_optimo[i]);
    }

    return 0;
}

*/
